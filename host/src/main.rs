// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use alloy_primitives::{address, hex, Address, Bytes, Signature, U256};
use alloy_signer::SignerSync;
use alloy_signer_local::PrivateKeySigner;
use alloy_sol_types::sol;
use anyhow::Result;
use methods::{SINGLE_SIGN_ELF, SINGLE_SIGN_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};
use single_sign_types::{DigestRange, Input, Output};
use std::str::FromStr;
use serde_json::json;
// Bring in the digest verifier to ensure JSON shape conforms to EIP-712 expectations.
use single_sign_types::typed_data::verify_digest;

sol! {
    struct TokenPermissions {
        address token;
        uint256 amount;
    }

    struct PermitTransferFrom {
        TokenPermissions permitted;
        address spender;
        uint256 nonce;
        uint256 deadline;
    }
}

static PERMIT2_ADDRESS: Address = address!("0x000000000022D473030F116dDEE9F6B43aC78BA3");

fn address_hex(addr: Address) -> String {
    format!("{:#x}", addr)
}

fn u256_dec(value: U256) -> String {
    value.to_string()
}

/// Build an EIP-712 typed-data JSON for a single Permit2 PermitTransferFrom
/// Returns a compact JSON string with keys: types, primaryType, domain, message.
fn build_permit2_single_typed_data_json(
    domain_name: &str,
    chain_id: u64,
    verifying_contract: Address,
    permit: &PermitTransferFrom,
) -> String {
    let obj = json!({
        "domain": {
            "name": domain_name,
            "chainId": chain_id,
            "verifyingContract": address_hex(verifying_contract),
        },
        "types": {
            "EIP712Domain": [
                {"name": "name", "type": "string"},
                {"name": "chainId", "type": "uint256"},
                {"name": "verifyingContract", "type": "address"}
            ],
            "TokenPermissions": [
                {"name": "token", "type": "address"},
                {"name": "amount", "type": "uint256"}
            ],
            "PermitTransferFrom": [
                {"name": "permitted", "type": "TokenPermissions"},
                {"name": "spender", "type": "address"},
                {"name": "nonce", "type": "uint256"},
                {"name": "deadline", "type": "uint256"}
            ]
        },
        "primaryType": "PermitTransferFrom",
        "message": {
            "permitted": {
                "token": address_hex(permit.permitted.token),
                "amount": u256_dec(permit.permitted.amount),
            },
            "spender": address_hex(permit.spender),
            "nonce": u256_dec(permit.nonce),
            "deadline": u256_dec(permit.deadline),
        }
    });

    serde_json::to_string(&obj).expect("serialization should succeed")
}

/// Create three fully separate PermitTransferFroms for the same token but different spenders.
fn make_three_permit_transfers_for_token(token: Address) -> Vec<PermitTransferFrom> {
    let spender1 = Address::from_str("0x1111111111111111111111111111111111111111").unwrap();
    let spender2 = Address::from_str("0x2222222222222222222222222222222222222222").unwrap();
    let spender3 = Address::from_str("0x3333333333333333333333333333333333333333").unwrap();

    vec![
        PermitTransferFrom {
            permitted: TokenPermissions { token, amount: U256::from(100) },
            spender: spender1,
            nonce: U256::from(0),
            deadline: U256::from_str("1737072000").unwrap(),
        },
        PermitTransferFrom {
            permitted: TokenPermissions { token, amount: U256::from(200) },
            spender: spender2,
            nonce: U256::from(1),
            deadline: U256::from_str("1737072000").unwrap(),
        },
        PermitTransferFrom {
            permitted: TokenPermissions { token, amount: U256::from(300) },
            spender: spender3,
            nonce: U256::from(2),
            deadline: U256::from_str("1737072000").unwrap(),
        },
    ]
}

fn main() -> Result<()> {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Construct a sample Input (placeholder values)
    println!("Signing message...");
    let signer = PrivateKeySigner::random();
    // Create 3 separate permits for the same token but different spenders
    let token = Address::from_str("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48").unwrap(); // USDC
    let permits: Vec<PermitTransferFrom> = make_three_permit_transfers_for_token(token);

    // Build a JSON for each permit and compute its EIP-712 digest to validate the schema
    let permit_jsons: Vec<String> = permits
        .iter()
        .map(|p| build_permit2_single_typed_data_json("Permit2", 1, PERMIT2_ADDRESS, p))
        .collect();
    for (i, j) in permit_jsons.iter().enumerate() {
        let d = verify_digest(j).expect("valid EIP-712 typed-data JSON");
        println!("Permit #{i} digest: 0x{}", hex::encode(d));
    }

    // Pack all JSONs into a single compact string and compute per-permit ranges
    let compact_parts: Vec<String> = permit_jsons
        .iter()
        .map(|j| j.chars().filter(|c| *c != ' ' && *c != '\n').collect())
        .collect();
    let mut start_offset: usize = 0;
    let mut digest_ranges: Vec<DigestRange> = Vec::with_capacity(compact_parts.len());
    for part in &compact_parts {
        let end = start_offset + part.len();
        digest_ranges.push(DigestRange { start: start_offset, end });
        start_offset = end;
    }
    let json_compact_all: String = compact_parts.concat();
    let typed_data_concat: Bytes = Bytes::from(json_compact_all.clone().into_bytes());
    let signature: Signature = signer.sign_message_sync(&typed_data_concat)?;

    println!("Digest ranges: {:?}", digest_ranges);

    // Prove each digest separately by providing the corresponding range
    for (i, range) in digest_ranges.iter().enumerate() {
        let input = Input {
            signer: signer.address(),
            signature,
            typed_data_concat: typed_data_concat.clone(),
            digest_range: range.clone(),
        };
        println!("Input #{i}: {:?}", input);

        let env = ExecutorEnv::builder()
            .write(&input)
            .unwrap()
            .build()
            .unwrap();

        println!("Environment made for input #{i}");

        // Obtain the default prover.
        let prover = default_prover();

        println!("Proving input #{i}");

        // Proof information by proving the specified ELF binary.
        // This struct contains the receipt along with statistics about execution of the guest
        let prove_info = prover.prove(env, SINGLE_SIGN_ELF).unwrap();

        println!("Prove info #{i}: {:?}", prove_info);

        // extract the receipt.
        let receipt = prove_info.receipt;

        println!("Receipt #{i}: {:?}", receipt);

        // Decode public output committed by the guest
        let output: Output = receipt.journal.decode().unwrap();
        println!(
            "Guest output #{i} -> signer: {:#x}, digest: 0x{}",
            output.signer,
            hex::encode(output.digest),
        );

        println!("Output #{i}: {:?}", output);

        // The receipt was verified at the end of proving, but the below code is an
        // example of how someone else could verify this receipt.
        receipt.verify(SINGLE_SIGN_ID).unwrap();

        println!("Receipt #{i} verified");
    }

    Ok(())
}
